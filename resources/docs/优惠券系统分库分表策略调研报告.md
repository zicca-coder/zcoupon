# 优惠券系统分库分表策略调研报告

## 1. 业务场景分析

基于当前优惠券模板实体 `CouponTemplate` 的设计，主要业务场景包括：

### 1.1 核心查询场景
- **店铺维度查询**：查询某个店铺的可用优惠券（高频场景）
- **用户维度查询**：用户查看已领取的优惠券列表（跨店铺）
- **平台管理查询**：平台人员管理所有优惠券（跨店铺）
- **商品维度查询**：查询适用于特定商品的优惠券

### 1.2 数据特征
- **店铺券**：绑定特定店铺，查询相对集中
- **平台券**：可跨店铺使用，查询分散
- **时效性强**：优惠券有明确的有效期
- **读多写少**：查询频率远高于创建/修改频率

## 2. 主流电商分库分表策略

### 2.1 策略一：店铺ID分片（单一分片键）

#### 实施方案
```sql
-- 分片键：shop_numbers
-- 分片算法：shop_numbers % 分片数
```

#### 优势
- 店铺维度查询性能最优（单库查询）
- 数据分布相对均匀（假设店铺规模相近）
- 实现简单，运维成本低

#### 劣势
- 跨店铺查询需要扫描所有分片（读扩散）
- 平台券查询性能差
- 用户维度查询需要额外的索引表

### 2.2 策略二：用户ID分片（用户维度优化）

#### 实施方案
```sql
-- 分片键：user_id（需要在优惠券领取表中）
-- 分片算法：user_id % 分片数
```

#### 优势
- 用户查询已领取优惠券性能最优
- 符合C端用户查询习惯

#### 劣势
- 店铺查询需要读扩散
- 数据分布可能不均匀（活跃用户差异大）
- 不适用于优惠券模板表

### 2.3 策略三：混合分片策略（推荐）

#### 实施方案
```sql
-- 方案A：按业务类型分表 + 店铺ID分片
CREATE TABLE t_coupon_template_shop_xxx   -- 店铺券表
CREATE TABLE t_coupon_template_platform_xxx -- 平台券表

-- 方案B：复合分片键
-- 分片键：HASH(shop_numbers, source) % 分片数
```

#### 优势
- 针对不同业务场景优化
- 减少跨分片查询
- 数据分布更均匀

#### 劣势
- 实现复杂度较高
- 需要应用层路由逻辑

### 2.4 策略四：时间 + 业务维度分片

#### 实施方案
```sql
-- 分片维度：时间（月份）+ 店铺ID
-- 表名：t_coupon_template_202401_shop_001
```

#### 优势
- 历史数据自然分离
- 便于数据归档和清理
- 查询性能稳定

#### 劣势
- 跨时间段查询复杂
- 分片数量增长快

## 3. 实际电商案例分析

### 3.1 淘宝/天猫模式
- **主策略**：店铺ID + 时间维度分片
- **辅助策略**：用户维度建立索引表
- **特点**：店铺券和平台券分别存储，通过中间件统一查询

### 3.2 京东模式
- **主策略**：混合分片（业务类型 + 店铺ID）
- **辅助策略**：ES搜索引擎支持复杂查询
- **特点**：读写分离，查询走搜索引擎

### 3.3 美团模式
- **主策略**：地理位置 + 商户ID分片
- **辅助策略**：Redis缓存热点数据
- **特点**：结合LBS特性，地域化分片

## 4. 推荐方案

### 4.1 核心推荐：业务分离 + 店铺分片

```sql
-- 店铺券表（按店铺ID分片）
CREATE TABLE t_coupon_template_shop_{分片号} (
    -- 原有字段
    -- 分片键：shop_numbers
);

-- 平台券表（按时间分片或集中存储）
CREATE TABLE t_coupon_template_platform_{时间分片} (
    -- 原有字段
    -- 适合集中存储或按时间分片
);

-- 用户优惠券索引表（按用户ID分片）
CREATE TABLE t_user_coupon_index_{分片号} (
    user_id BIGINT,
    coupon_template_id BIGINT,
    shop_id BIGINT,
    status INT,
    -- 其他索引字段
);
```

### 4.2 查询路由策略

#### 店铺维度查询
```java
// 直接路由到对应分片
String tableName = "t_coupon_template_shop_" + (shopId % shardCount);
```

#### 用户维度查询
```java
// 通过索引表查询
String indexTable = "t_user_coupon_index_" + (userId % shardCount);
// 再根据coupon_template_id查询详情
```

#### 平台管理查询
```java
// 使用ES或者数据仓库进行聚合查询
// 或者异步同步到专门的查询库
```

### 4.3 技术架构建议

#### 中间件选择
- **ShardingSphere**：支持复杂分片策略
- **MyCat**：轻量级分库分表中间件
- **自研路由**：基于业务特性定制

#### 缓存策略
```java
// 热点优惠券缓存
Redis: coupon:template:{shopId}:{templateId}
// 用户优惠券列表缓存
Redis: user:coupons:{userId}
```

#### 搜索引擎
```java
// ES索引设计
{
  "mappings": {
    "properties": {
      "shop_id": {"type": "long"},
      "user_id": {"type": "long"},
      "template_id": {"type": "long"},
      "status": {"type": "integer"},
      "valid_time": {"type": "date_range"}
    }
  }
}
```

## 5. 实施建议

### 5.1 分阶段实施
1. **第一阶段**：按店铺ID分片，解决核心查询场景
2. **第二阶段**：引入索引表，优化用户查询
3. **第三阶段**：引入搜索引擎，支持复杂查询

### 5.2 数据迁移策略
- 使用双写方案平滑迁移
- 灰度验证数据一致性
- 逐步切换读流量

### 5.3 监控和运维
- 分片数据量监控
- 跨分片查询性能监控
- 热点数据识别和优化

## 6. 总结

对于优惠券系统，推荐采用**业务分离 + 店铺分片**的混合策略：

1. **店铺券**：按店铺ID分片，满足高频查询场景
2. **平台券**：集中存储或按时间分片，数量相对较少
3. **用户查询**：通过索引表 + 缓存优化
4. **复杂查询**：引入搜索引擎支持

这种方案能够在保证核心业务性能的同时，通过技术手段解决读扩散问题，是目前主流电商平台采用的成熟方案。